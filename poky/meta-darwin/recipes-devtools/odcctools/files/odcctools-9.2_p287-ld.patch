Index: ld/ld.c
===================================================================
--- ld/ld.c	(revision 287)
+++ ld/ld.c	(working copy)
@@ -29,7 +29,7 @@
  * miscellaneous small global routines.  It also defines the global varaibles
  * that are set or changed by command line arguments.
  */
-#include <stdlib.h>
+#define _GNU_SOURCE
 #include <string.h>
 #include <stdarg.h>
 #include <sys/types.h>
@@ -54,6 +54,7 @@
 #include <ar.h>
 #include <mach/mach.h>
 #include <mach/mach_error.h>
+#include <foreign/mach/mach_traps.h>
 #include "stuff/seg_addr_table.h"
 #ifndef RLD
 #include "stuff/symbol_list.h"
Index: ld/arm_reloc.c
===================================================================
--- ld/arm_reloc.c	(revision 287)
+++ ld/arm_reloc.c	(working copy)
@@ -57,6 +57,89 @@
 #define U_ABS(l) (((long)(l))<0 ? (unsigned long)(-(l)) : (l))
 
 /*
+ * fine_reloc_arm() returns TRUE if fine relocation entry for the input_offset
+ * in the section specified is for a symbol stub for a defined external symbol
+ * that is an arm symbol and stub will not be used.  This information is needed
+ * when relocating an arm branch instruction that is targetted to a symbol stub
+ * that ends up going to target the address of an arm symbol. Then in this case
+ * the branch instruction needs to be changed from a blx to a bl instruction.
+ */
+__private_extern__
+enum bool
+fine_reloc_arm(
+struct section_map *map,
+unsigned long input_offset)
+{
+    struct fine_reloc *fine_reloc;
+    struct merged_symbol *merged_symbol;
+
+        fine_reloc = fine_reloc_for_input_offset(map, input_offset);
+        if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
+            fine_reloc->indirect_defined == TRUE &&
+            (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
+            merged_symbol = fine_reloc->merged_symbol;
+            if(merged_symbol != NULL)
+                return((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF)
+                        != N_ARM_THUMB_DEF);
+        }
+        return(FALSE);
+}
+
+/*
+ * fine_reloc_thumb() returns TRUE if fine relocation entry for the input_offset
+ * in the section specified is for a symbol stub for a defined external symbol
+ * that a thumb symbol and stub will not be used.  This information is needed
+ * when relocating an arm branch instruction that is targetted to a symbol stub
+ * that ends up going to target the address of a thumb symbol. Then in this case
+ * the branch instruction needs to be changed to a branch and exchange
+ * instuction.
+ */
+__private_extern__
+enum bool
+fine_reloc_thumb(
+struct section_map *map,
+unsigned long input_offset)
+{
+    struct fine_reloc *fine_reloc;
+    struct merged_symbol *merged_symbol;
+
+        fine_reloc = fine_reloc_for_input_offset(map, input_offset);
+        if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
+            fine_reloc->indirect_defined == TRUE &&
+            (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
+            merged_symbol = fine_reloc->merged_symbol;
+            if(merged_symbol != NULL)
+                return((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF)
+                        == N_ARM_THUMB_DEF);
+        }
+        return(FALSE);
+}
+
+/*
+ * fine_reloc_local() returns TRUE if fine relocation entry for the input_offset
+ * in the section specified is for a symbol stub for a defined local symbol.
+ */
+__private_extern__
+enum bool
+fine_reloc_local(
+struct section_map *map,
+unsigned long input_offset)
+{
+    struct fine_reloc *fine_reloc;
+    struct merged_symbol *merged_symbol;
+
+        fine_reloc = fine_reloc_for_input_offset(map, input_offset);
+        if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
+            fine_reloc->indirect_defined == TRUE &&
+            (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
+            merged_symbol = fine_reloc->merged_symbol;
+            if(merged_symbol == NULL)
+                return(TRUE);
+        }
+        return(FALSE);
+}
+
+/*
  * arm_reloc() relocates the contents of the specified section for the 
  * relocation entries using the section map from the current object (cur_obj).
  *
Index: ld/pass1.c
===================================================================
--- ld/pass1.c	(revision 287)
+++ ld/pass1.c	(working copy)
@@ -29,6 +29,7 @@
  * the things that need to be merged from the input objects are merged into
  * tables (for output and relocation on the second pass).
  */
+#define _GNU_SOURCE
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
@@ -6007,7 +6008,11 @@
  * symbols and if found sets *(int *)fail_p.
  */
 static int
+#if __GLIBC_PREREQ(2,8)
+symbol_address_compare (const void *a_p, const void *b_p, void *fail_p)
+#else
 symbol_address_compare (void *fail_p, const void *a_p, const void *b_p)
+#endif
 {
   const struct nlist * const * aa = a_p;
   const struct nlist * a = *aa;
@@ -6158,8 +6163,11 @@
   sst = allocate (sizeof (struct nlist *) * cur_obj->symtab->nsyms);
   for (i = 0; i < cur_obj->symtab->nsyms; i++)
     sst[i] = st + i;
-  qsort_r (sst, cur_obj->symtab->nsyms, sizeof (struct nlist *), &has_stabs,
-	   symbol_address_compare);
+#if __GLIBC_PREREQ(2,8)
+  qsort_r (sst, cur_obj->symtab->nsyms, sizeof (struct nlist *), symbol_address_compare, &has_stabs);
+#else
+  qsort_r (sst, cur_obj->symtab->nsyms, sizeof (struct nlist *), &has_stabs, symbol_address_compare);
+#endif
   if (has_stabs) {
     error_with_cur_obj("has both STABS and DWARF debugging info");
     free (sst);
Index: ld/objects.c
===================================================================
--- ld/objects.c	(revision 287)
+++ ld/objects.c	(working copy)
@@ -722,89 +722,6 @@
 }
 
 /*
- * fine_reloc_arm() returns TRUE if fine relocation entry for the input_offset
- * in the section specified is for a symbol stub for a defined external symbol 
- * that is an arm symbol and stub will not be used.  This information is needed
- * when relocating an arm branch instruction that is targetted to a symbol stub
- * that ends up going to target the address of an arm symbol. Then in this case
- * the branch instruction needs to be changed from a blx to a bl instruction.
- */
-__private_extern__
-enum bool
-fine_reloc_arm(
-struct section_map *map,
-unsigned long input_offset)
-{
-    struct fine_reloc *fine_reloc;
-    struct merged_symbol *merged_symbol;
-
-	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
-	if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
-	    fine_reloc->indirect_defined == TRUE &&
-	    (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
-	    merged_symbol = fine_reloc->merged_symbol;
-	    if(merged_symbol != NULL)
-		return((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF)
-			!= N_ARM_THUMB_DEF);
-	}
-	return(FALSE);
-}
-
-/*
- * fine_reloc_thumb() returns TRUE if fine relocation entry for the input_offset
- * in the section specified is for a symbol stub for a defined external symbol 
- * that a thumb symbol and stub will not be used.  This information is needed
- * when relocating an arm branch instruction that is targetted to a symbol stub
- * that ends up going to target the address of a thumb symbol. Then in this case
- * the branch instruction needs to be changed to a branch and exchange
- * instuction.
- */
-__private_extern__
-enum bool
-fine_reloc_thumb(
-struct section_map *map,
-unsigned long input_offset)
-{
-    struct fine_reloc *fine_reloc;
-    struct merged_symbol *merged_symbol;
-
-	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
-	if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
-	    fine_reloc->indirect_defined == TRUE &&
-	    (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
-	    merged_symbol = fine_reloc->merged_symbol;
-	    if(merged_symbol != NULL)
-		return((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF)
-			== N_ARM_THUMB_DEF);
-	}
-	return(FALSE);
-}
-
-/*
- * fine_reloc_local() returns TRUE if fine relocation entry for the input_offset
- * in the section specified is for a symbol stub for a defined local symbol.
- */
-__private_extern__
-enum bool
-fine_reloc_local(
-struct section_map *map,
-unsigned long input_offset)
-{
-    struct fine_reloc *fine_reloc;
-    struct merged_symbol *merged_symbol;
-
-	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
-	if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
-	    fine_reloc->indirect_defined == TRUE &&
-	    (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
-	    merged_symbol = fine_reloc->merged_symbol;
-	    if(merged_symbol == NULL)
-		return(TRUE);
-	}
-	return(FALSE);
-}
-
-/*
  * fine_reloc_for_input_offset() returns the fine relocation entry for the
  * specified input offset and the section map.
  */
